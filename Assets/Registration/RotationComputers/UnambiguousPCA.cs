using System;
using System.Collections.Generic;
using MathNet.Numerics.LinearAlgebra;

namespace DataView
{
    /// <summary>
    /// This class works the same as TestRotationComputerPCA,
    /// but the basis of micro and macro data is generated by getting uniformly distributed values
    /// </summary>
    class UnambiguousPCA
    {
        public static double radius = 1;

        /// <summary>
        /// Calculates the rotation matrix from dMicro to dMacro
        /// </summary>
        /// <param name="dMicro">Data1</param>
        /// <param name="dMacro">Data2</param>
        /// <param name="pointMicro">Point in data1 to take samples around</param>
        /// <param name="pointMacro">Point in data2 to take samples around</param>
        /// <param name="count">Number of samples taken</param>
        /// <returns>Returns rotation matrix</returns>
        public static Matrix<double> CalculateRotation(IData dMicro, IData dMacro, Point3D pointMicro, Point3D pointMacro, double spacing)
        {
            Matrix<double> basisMicro;
            Matrix<double> basisMacro;

            spacing = 0.3;

            try
            {
                basisMicro = GetPointBasis(dMicro, pointMicro, spacing, radius);
                basisMacro = GetPointBasis(dMacro, pointMacro, spacing, radius);
            }
            catch (Exception e) { throw e; }

            Matrix<double> resultMatrix = CalculateTransitionMatrix(basisMicro, basisMacro);
            return resultMatrix;
        }

        /// <summary>
        /// Calculates the transition matrix between two given bases
        /// </summary>
        /// <param name="basisMicro">Micro basis</param>
        /// <param name="basisMacro">Macro basis</param>
        /// <returns>Returns transition matrix</returns>
        private static Matrix<double> CalculateTransitionMatrix(Matrix<double> basisMicro, Matrix<double> basisMacro)
        {
            Matrix<double> transitionMatrix = Matrix<double>.Build.Dense(3, 3);

            Matrix<double> equationMatrix = Matrix<double>.Build.Dense(3, 4);


            //Calculation of the transition matrix
            for (int basisNumber = 0; basisNumber < 3; basisNumber++)
            {
                for (int i = 0; i < 3; i++)
                    equationMatrix.SetColumn(i, basisMicro.Column(i));

                equationMatrix.SetColumn(3, basisMacro.Column(basisNumber));

                Vector<double> result;

                try { result = EquationComputer.CalculateSolution(equationMatrix); }
                catch (Exception e) { throw e; }

                transitionMatrix.SetColumn(basisNumber, result);
            }

            //Replace 0 values
            for (int i = 0; i < transitionMatrix.RowCount; i++)
            {
                for (int j = 0; j < transitionMatrix.ColumnCount; j++)
                {
                    if (Math.Abs(transitionMatrix[i, j]) <= Double.Epsilon)
                        transitionMatrix[i, j] = 0;
                }
            }

            return transitionMatrix;
        }

        // od pana Váši
        private static Matrix<double> GetPointBasis(IData d, Point3D point, double spacing, double radius)
        {
            List<Point3D> pointsInSphere = GetSphere(point, radius, spacing, d);
            List<double> values = new List<double>();

            SphereBounds sampledValues = GetSampledValues(d, pointsInSphere, values);
            double min = sampledValues.MinCoordinate;
            double max = sampledValues.MaxCoordinate;

            if (Math.Abs(min - max) < Double.Epsilon)
                throw new ArgumentException("Basis cannot be calculated because all sampled values in the point surrounding are the same.");

            Vector<double> averageDirection = Vector<double>.Build.Dense(3);
            Matrix<double> weightedOuterProductMatrix = Matrix<double>.Build.Dense(3, 3);

            double weightSum = 0;

            for (int i = 0; i < pointsInSphere.Count; i++)
            {
                double weight = (values[i] - min) / (max - min); // Calculate the weight

                Vector<double> currentAddition = Vector<double>.Build.DenseOfArray(new double[] {
                    pointsInSphere[i].X * weight,
                    pointsInSphere[i].Y * weight,
                    pointsInSphere[i].Z * weight
                });

                Vector<double> anotherAddition = Vector<double>.Build.DenseOfArray(new double[] {
                    pointsInSphere[i].X,
                    pointsInSphere[i].Y,
                    pointsInSphere[i].Z
                });


                averageDirection += currentAddition;

                weightedOuterProductMatrix += currentAddition.ToColumnMatrix() * anotherAddition.ToRowMatrix();

                weightSum += weight;
            }

            averageDirection /= weightSum;
            weightedOuterProductMatrix /= weightSum;

            var evd = weightedOuterProductMatrix.Evd();
            Matrix<double> decomposedMatrix = evd.EigenVectors;

            Matrix<double> transformedBasis = Matrix<double>.Build.Dense(decomposedMatrix.RowCount, decomposedMatrix.ColumnCount);

            for (int i = 0; i< decomposedMatrix.ColumnCount; i++)
            {
                double sign = Math.Sign(averageDirection.DotProduct(decomposedMatrix.Column(i)));

                //transformedBasis.SetColumn(i, sign * decomposedMatrix.Column(i));

                for(int j = 0; j< decomposedMatrix.RowCount; j++)
                    transformedBasis[j, i] = sign * decomposedMatrix[j, i];
            }

            return transformedBasis;
        }

        private static SphereBounds GetSampledValues(IData d, List<Point3D> pointsInSphere, List<double> values)
        {
            double min = double.MaxValue;
            double max = double.MinValue;

            for (int i = 0; i < pointsInSphere.Count; i++)
            {
                values.Add(d.GetValue(pointsInSphere[i])); //All values are within bounds, no need to test it
                min = Math.Min(min, values[values.Count - 1]);
                max = Math.Max(max, values[values.Count - 1]);
            }

            return new SphereBounds(min, max);
        }

        /// <summary>
        /// Gets points uniformly distributed from the center point
        /// </summary>
        /// <param name="p">Center around which the points are generated</param>
        /// <param name="r">Generated point's distance from the center</param>
        /// <param name="spacing">Spacing between the points</param>
        /// <param name="data">Data unsed for checking if the value is within bounds of the object.</param>
        /// <returns>A grid of points uniformly distributed in the sphere radius from a given point.</returns>
        private static List<Point3D> GetSphere(Point3D p, double r, double spacing, IData data)
        {
            List<Point3D> points = new List<Point3D>();

            for (double x = -r; x <= r; x += spacing)
            {
                for (double y = -r; y <= r; y += spacing)
                {
                    SphereBounds zBounds;

                    try { zBounds = GetSphereBounds(x, y, r); }
                    catch { continue; } //No point in z is in the bounds

                    for (double z = zBounds.MinCoordinate; z <= zBounds.MaxCoordinate; z += spacing)
                    {
                        Point3D point = new Point3D(x + p.X, y + p.Y, z + p.Z);
                        if (IsWithinBounds(data, point))
                            points.Add(point);
                    }
                }
            }

            return points;
        }

        /// <summary>
        /// This method tests if the point is within the bounds of an object provided as a parameter data
        /// </summary>
        /// <param name="data">Data instance for the object</param>
        /// <param name="p">Point tested</param>
        /// <returns>Returns true if point is within the bounds, false otherwise.</returns>
        private static bool IsWithinBounds(IData data, Point3D p)
        {
            if (p.X < 0 || p.X > (data.Measures[0] - data.XSpacing))
                return false;

            if (p.Y < 0 || p.Y > (data.Measures[1] - data.YSpacing))
                return false;

            if (p.Z < 0 || p.Z > (data.Measures[2] - data.ZSpacing))
                return false;

            return true;
        }


        /// <summary>
        /// Given an x and y coordinates, this method will generate a min and max z coordinate
        /// so that [x, y, z] are inside a sphere specified by given radius
        /// </summary>
        /// <param name="x">Coordinate X</param>
        /// <param name="y">Coordinate Y</param>
        /// <param name="radius">Radius of a sphere</param>
        /// <returns>Returns instance of SphereBounds where are the min and max Z values.</returns>
        /// <exception cref="ArgumentException">Throws an exception if the bounds for Z don't exist.</exception>
        private static SphereBounds GetSphereBounds(double x, double y, double radius)
        {
            double rSquared = Math.Pow(radius, 2);
            double zSquared = rSquared - Math.Pow(x, 2) - Math.Pow(y, 2);

            if (zSquared < 0)
                throw new ArgumentException("No values are within bounds for the given X, Y coordinates and given radius");

            double minZ = -Math.Sqrt(zSquared);
            double maxZ = -minZ;

            return new SphereBounds(minZ, maxZ);
        }
    }
}