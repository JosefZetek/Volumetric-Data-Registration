using System;
using System.Collections.Generic;
using System.Linq;
using MathNet.Numerics.LinearAlgebra;
using MathNet.Numerics.LinearAlgebra.Factorization;

namespace DataView
{
    /// <summary>
    /// This class works the same as TestRotationComputerPCA,
    /// but the basis of micro and macro data is generated by getting uniformly distributed values
    /// </summary>
    public class UniformRotationComputerPCA
    {
        public static double radius = 2;

        /// <summary>
        /// Calculates the rotation matrix from dMicro to dMacro
        /// </summary>
        /// <param name="dMicro">Data1</param>
        /// <param name="dMacro">Data2</param>
        /// <param name="pointMicro">Point in data1 to take samples around</param>
        /// <param name="pointMacro">Point in data2 to take samples around</param>
        /// <param name="count">Number of samples taken</param>
        /// <returns>Returns rotation matrix</returns>
        public static Matrix<double> CalculateRotation(AData dMicro, AData dMacro, Point3D pointMicro, Point3D pointMacro, double spacing)
        {
            Matrix<double> basisMicro = GetPointBasis(dMicro, pointMicro, spacing, radius, "micro.csv");
            Matrix<double> basisMacro = GetPointBasis(dMacro, pointMacro, spacing, radius, "macro.csv");

            Console.WriteLine($"Micro: {basisMicro}");
            Console.WriteLine($"Macro: {basisMacro}");

            return CalculateTransitionMatrix(basisMicro, basisMacro);
        }

        private static Vector<double> CrossProduct(Vector<double> firstVector, Vector<double> secondVector)
        {
            return Vector<double>.Build.DenseOfArray(new double[] {
                firstVector[1] * secondVector[2] - firstVector[2] * secondVector[1],
                firstVector[2] * secondVector[0] - firstVector[0] * secondVector[2],
                firstVector[0] * secondVector[1] - firstVector[1] * secondVector[0]
            });
        }

        private static Matrix<double> AdjustBasis(Matrix<double> basis, int i, int j)
        {
            if (basis.ColumnCount != 3 || basis.RowCount != 3)
                throw new ArgumentException("Basis needs to have dimensions 3x3");

            Vector<double> vector1 = i * basis.Column(0);
            Vector<double> vector2 = j * basis.Column(1);

            Vector<double> vector3 = CrossProduct(vector1, vector2);

            Matrix<double> adjustedMatrix = Matrix<double>.Build.Dense(3, 3);

            adjustedMatrix.SetColumn(0, vector1);
            adjustedMatrix.SetColumn(1, vector2);
            adjustedMatrix.SetColumn(2, vector3);

            return adjustedMatrix;
        }

        /// <summary>
        /// Calculates the transition matrix between two given bases
        /// </summary>
        /// <param name="basisMicro">Micro basis</param>
        /// <param name="basisMacro">Macro basis</param>
        /// <returns>Returns transition matrix</returns>
        private static Matrix<double> TransitionMatrixAnalytically(Matrix<double> basisMicro, Matrix<double> basisMacro)
        {
            Matrix<double> transitionMatrix = Matrix<double>.Build.Dense(3, 3);

            Matrix<double> equationMatrix = Matrix<double>.Build.Dense(3, 4);


            //Calculation of the transition matrix
            for (int basisNumber = 0; basisNumber < 3; basisNumber++)
            {
                for (int i = 0; i < 3; i++)
                    equationMatrix.SetColumn(i, basisMicro.Column(i));

                equationMatrix.SetColumn(3, basisMacro.Column(basisNumber));

                Vector<double> result;

                try { result = EquationComputer.CalculateSolution(equationMatrix); }
                catch (Exception e) { throw e; }

                transitionMatrix.SetColumn(basisNumber, result);
            }

            //Replace 0 values
            for (int i = 0; i < transitionMatrix.RowCount; i++)
            {
                for (int j = 0; j < transitionMatrix.ColumnCount; j++)
                {
                    if (Math.Abs(transitionMatrix[i, j]) <= Double.Epsilon)
                        transitionMatrix[i, j] = 0;
                }
            }

            return transitionMatrix;
        }

        private static Matrix<double> CalculateTransitionMatrix(Matrix<double> basisMicro, Matrix<double> basisMacro)
        {
            return basisMacro * basisMicro.Inverse();
        }

        private static void Save(string outputFilename, string prefix, List<Point3D> points, List<double> values)
        {
            double[][] csvOutput = new double[points.Count][];

            for (int i = 0; i < csvOutput.Length; i++)
                csvOutput[i] = new double[] { points[i].X, points[i].Y, points[i].Z, values[i] };

            CSVWriter.WriteResult("/Users/pepazetek/Desktop/" + prefix + "_" + outputFilename, csvOutput);
        }

        // od pana Váši
        public static Matrix<double> GetPointBasis(AData d, Point3D point, double spacing, double radius, string outputFilename)
        {
            List<Point3D> points = GetSphere(point, radius, spacing, d);
            List<double> values = CalculateValues(points, d);

            //Save(outputFilename, "unfiltered", points, values);

            /* Threshold to filter insignificant  values */
            QuickSelectClass quickSelectClass = new QuickSelectClass();
            double threshold = quickSelectClass.QuickSelect(values, values.Count / 2);
            FilterPoints(ref points, ref values, threshold);


            //Save(outputFilename, "filtered", points, values);

            Vector<double> meanVector = CalculateWeightedMeanVector(points);
            Console.WriteLine("Mean " + outputFilename + ":\n" + meanVector);

            Matrix<double> covarianceMatrix = CalculateCovarianceMatrix(points, meanVector);
            Console.WriteLine("Covariance matrix " + outputFilename + ":\n" + covarianceMatrix);

            Matrix<double> basisMatrix = GetEigenVectors(covarianceMatrix.Evd());
            //Vector<double> gradient = GradientCalculator.GetFunctionGradient(point, d);

            AdjustBasis(basisMatrix, point.Coordinates);

            return basisMatrix;
        }

        private static void AdjustBasis(Matrix<double> basisMatrix, Vector<double> gradient)
        {
            Vector<double> temp;
            for (int i = 0; i < 2; i++)
            {
                temp = basisMatrix.Column(i);
                basisMatrix.SetColumn(i, Math.Sign(temp.DotProduct(gradient)) * temp);
            }

            basisMatrix.SetColumn(2, CrossProduct(basisMatrix.Column(0), basisMatrix.Column(1)));
        }

        private static Matrix<double> GetEigenVectors(Evd<double> evd)
        {
            Vector<double> eigenValues = evd.EigenValues.Real();
            Matrix<double> eigenVectors = evd.EigenVectors;

            // Get indices sorted by eigenvalues in descending order
            int[] sortedIndices = eigenValues.Enumerate()
                                             .Select((value, index) => (value, index))
                                             .OrderByDescending(pair => pair.value)
                                             .Select(pair => pair.index)
                                             .ToArray();

            Matrix<double> sortedEigenVectors = Matrix<double>.Build.Dense(eigenVectors.RowCount, eigenVectors.ColumnCount);

            for (int i = 0; i < sortedIndices.Length; i++)
                sortedEigenVectors.SetColumn(i, eigenVectors.Column(sortedIndices[i]));

            return sortedEigenVectors;
        }

        private static List<double> CalculateValues(List<Point3D> points, AData d)
        {
            List<double> values = new List<double>();
            double min = double.MaxValue, max = double.MinValue;

            for (int i = 0; i < points.Count; i++)
            {
                values.Add(d.GetValue(points[i]));
                min = Math.Min(min, values[values.Count - 1]);
                max = Math.Max(max, values[values.Count - 1]);
            }

            if (Math.Abs(min - max) < Double.Epsilon)
                throw new ArgumentException("Basis cannot be calculated because all sampled values in the point surrounding are the same.");

            return values;
        }

        private static void FilterPoints(ref List<Point3D> points, ref List<double> values, double threshold)
        {

            List<Point3D> filteredPoints = new List<Point3D>();
            List<double> filteredValues = new List<double>();

            for (int i = 0; i < points.Count; i++)
            {
                if (values[i] >= threshold)
                {
                    filteredValues.Add(values[i]);
                    filteredPoints.Add(points[i]);
                }
            }

            points = filteredPoints;
            values = filteredValues;
        }

        private static Matrix<double> CalculateCovarianceMatrix(List<Point3D> pointsInSphere, Vector<double> meanVector)
        {
            int N = pointsInSphere.Count;
            Matrix<double> A = Matrix<double>.Build.Dense(N, 3); // Each row is a point (N x 3)

            for (int i = 0; i < N; i++)
            {
                A.SetRow(i, new double[] {
                    pointsInSphere[i].X - meanVector[0],
                    pointsInSphere[i].Y - meanVector[1],
                    pointsInSphere[i].Z - meanVector[2]
                });
            }

            return (A.Transpose() * A) / (N - 1); // (3xN) * (Nx3) = 3x3 covariance matrix
        }

        private static Vector<double> CalculateWeightedMeanVector(List<Point3D> pointsInSphere)
        {
            Vector<double> meanVector = Vector<double>.Build.Dense(3);

            for (int i = 0; i < pointsInSphere.Count; i++)
            {
                meanVector[0] += pointsInSphere[i].X;
                meanVector[1] += pointsInSphere[i].Y;
                meanVector[2] += pointsInSphere[i].Z;
            }

            meanVector /= pointsInSphere.Count;
            return meanVector;
        }

        /// <summary>
        /// Gets points uniformly distributed from the center point
        /// </summary>
        /// <param name="p">Center around which the points are generated</param>
        /// <param name="r">Generated point's distance from the center</param>
        /// <param name="spacing">Spacing between the points</param>
        /// <param name="data">Data unsed for checking if the value is within bounds of the object.</param>
        /// <returns>A grid of points uniformly distributed in the sphere radius from a given point.</returns>
        private static List<Point3D> GetSphere(Point3D p, double r, double spacing, AData data)
        {
            List<Point3D> points = new List<Point3D>();

            for (double x = -r; x <= r; x += spacing)
            {
                for (double y = -r; y <= r; y += spacing)
                {
                    SphereBounds zBounds;

                    try { zBounds = GetSphereBounds(x, y, r); }
                    catch { continue; } //No point in z is in the bounds

                    for (double z = zBounds.MinCoordinate; z <= zBounds.MaxCoordinate; z += spacing)
                    {
                        Point3D point = new Point3D(x + p.X, y + p.Y, z + p.Z);
                        if (data.PointWithinBounds(point))
                            points.Add(point);
                    }
                }
            }

            return points;
        }

        /// <summary>
        /// Given an x and y coordinates, this method will generate a min and max z coordinate
        /// so that [x, y, z] are inside a sphere specified by given radius
        /// </summary>
        /// <param name="x">Coordinate X</param>
        /// <param name="y">Coordinate Y</param>
        /// <param name="radius">Radius of a sphere</param>
        /// <returns>Returns instance of SphereBounds where are the min and max Z values.</returns>
        /// <exception cref="ArgumentException">Throws an exception if the bounds for Z don't exist.</exception>
        private static SphereBounds GetSphereBounds(double x, double y, double radius)
        {
            double rSquared = Math.Pow(radius, 2);
            double zSquared = rSquared - Math.Pow(x, 2) - Math.Pow(y, 2);

            if (zSquared < 0)
                throw new ArgumentException("No values are within bounds for the given X, Y coordinates and given radius");

            double minZ = -Math.Sqrt(zSquared);
            double maxZ = -minZ;
            return new SphereBounds(minZ, maxZ);
        }
    }
}