using System;
using System.Collections.Generic;
using MathNet.Numerics.LinearAlgebra;

namespace DataView
{
    /// <summary>
    /// This class works the same as TestRotationComputerPCA,
    /// but the basis of micro and macro data is generated by getting uniformly distributed values
    /// </summary>
    public class UniformRotationComputerPCA
    {
        public static double radius = 3;

        /// <summary>
        /// Calculates the rotation matrix from dMicro to dMacro
        /// </summary>
        /// <param name="dMicro">Data1</param>
        /// <param name="dMacro">Data2</param>
        /// <param name="pointMicro">Point in data1 to take samples around</param>
        /// <param name="pointMacro">Point in data2 to take samples around</param>
        /// <param name="count">Number of samples taken</param>
        /// <returns>Returns rotation matrix</returns>
        public static List<Matrix<double>> CalculateRotation(AData dMicro, AData dMacro, Point3D pointMicro, Point3D pointMacro, double spacing)
        {
            Matrix<double> basisMicro;
            Matrix<double> basisMacro;

            List<Matrix<double>> rotationMatrices = new List<Matrix<double>>();
            Matrix<double> transitionMatrix;

            spacing = 0.1;

            try
            {
                basisMicro = GetPointBasis(dMicro, pointMicro, spacing, radius);
                basisMacro = AdjustBasis(GetPointBasis(dMacro, pointMacro, spacing, radius), 1, 1);
            }
            catch (Exception e) { throw e; }

            for(int i = -1; i<=1; i+=2)
            {
                for (int j = -1; j <= 1; j+=2)
                {

                    transitionMatrix = CalculateTransitionMatrix(AdjustBasis(basisMicro, i, j), basisMacro);
                    rotationMatrices.Add(transitionMatrix);
                }
            }

            
            return rotationMatrices;
        }

        private static Vector<double> CrossProduct(Vector<double> firstVector, Vector<double> secondVector)
        {
            return Vector<double>.Build.DenseOfArray(new double[] {
                firstVector[1] * secondVector[2] - firstVector[2] * secondVector[1],
                firstVector[2] * secondVector[0] - firstVector[0] * secondVector[2],
                firstVector[0] * secondVector[1] - firstVector[1] * secondVector[0]
            });
        }

        private static Matrix<double> AdjustBasis(Matrix<double> basis, int i, int j)
        {
            if (basis.ColumnCount != 3 || basis.RowCount != 3)
                throw new ArgumentException("Basis needs to have dimensions 3x3");

            Vector<double> vector1 = i * basis.Column(0);
            Vector<double> vector2 = j * basis.Column(1);

            Vector<double> vector3 = CrossProduct(vector1, vector2);

            Matrix<double> adjustedMatrix = Matrix<double>.Build.Dense(3, 3);

            adjustedMatrix.SetColumn(0, vector1);
            adjustedMatrix.SetColumn(1, vector2);
            adjustedMatrix.SetColumn(2, vector3);

            return adjustedMatrix;
        }

        /// <summary>
        /// Calculates the transition matrix between two given bases
        /// </summary>
        /// <param name="basisMicro">Micro basis</param>
        /// <param name="basisMacro">Macro basis</param>
        /// <returns>Returns transition matrix</returns>
        private static Matrix<double> TransitionMatrixAnalytically(Matrix<double> basisMicro, Matrix<double> basisMacro)
        {
            Matrix<double> transitionMatrix = Matrix<double>.Build.Dense(3, 3);

            Matrix<double> equationMatrix = Matrix<double>.Build.Dense(3, 4);


            //Calculation of the transition matrix
            for (int basisNumber = 0; basisNumber < 3; basisNumber++)
            {
                for (int i = 0; i < 3; i++)
                    equationMatrix.SetColumn(i, basisMicro.Column(i));

                equationMatrix.SetColumn(3, basisMacro.Column(basisNumber));

                Vector<double> result;

                try { result = EquationComputer.CalculateSolution(equationMatrix); }
                catch (Exception e) { throw e; }

                transitionMatrix.SetColumn(basisNumber, result);
            }

            //Replace 0 values
            for (int i = 0; i < transitionMatrix.RowCount; i++)
            {
                for (int j = 0; j < transitionMatrix.ColumnCount; j++)
                {
                    if (Math.Abs(transitionMatrix[i, j]) <= Double.Epsilon)
                        transitionMatrix[i, j] = 0;
                }
            }

            return transitionMatrix;
        }

        private static Matrix<double> CalculateTransitionMatrix(Matrix<double> basisMicro, Matrix<double> basisMacro)
        {
            return basisMicro.Transpose() * basisMacro;
        }

        // od pana Váši
        private static Matrix<double> GetPointBasis(AData d, Point3D point, double spacing, double radius)
        {
            double max = 0;

            List<Point3D> points = GetSphere(point, radius, spacing, d);
            List<double> values = CalculateValues(points, d, ref max);

            QuickSelectClass quickSelectClass = new QuickSelectClass();

            /* Threshold to filter insignificant  values */
            double threshold = quickSelectClass.QuickSelect(values, values.Count / 2);

            FilterPoints(ref points, ref values, threshold);

            Vector<double> meanVector = CalculateWeightedMeanVector(points, values, threshold, max);

            Matrix<double> covarianceMatrix = CalculateCovarianceMatrix(points, values, meanVector);

            var evd = covarianceMatrix.Evd();
            return evd.EigenVectors;
        }

        private static List<double> CalculateValues(List<Point3D> points, AData d, ref double max)
        {
            List<double> values = new List<double>();
            double min = double.MaxValue;
            max = double.MinValue;

            for (int i = 0; i < points.Count; i++)
            {
                values.Add(d.GetValue(points[i]));
                min = Math.Min(min, values[values.Count - 1]);
                max = Math.Max(max, values[values.Count - 1]);
            }

            if (Math.Abs(min - max) < Double.Epsilon)
                throw new ArgumentException("Basis cannot be calculated because all sampled values in the point surrounding are the same.");

            return values;
        }

        private static void FilterPoints(ref List<Point3D> points, ref List<double> values, double threshold)
        {

            List<Point3D> filteredPoints = new List<Point3D>();
            List<double> filteredValues = new List<double>();

            for(int i = 0; i<points.Count; i++)
            {
                if (values[i] >= threshold)
                {
                    filteredValues.Add(values[i]);
                    filteredPoints.Add(points[i]);
                }
            }

            points = filteredPoints;
            values = filteredValues;
        }

        private static Matrix<double> CalculateCovarianceMatrix(List<Point3D> pointsInSphere, List<double> values, Vector<double> meanVector)
        {
            //Optimization needed
            Matrix<double> a = Matrix<double>.Build.Dense(3, pointsInSphere.Count);

            for (int i = 0; i < values.Count; i++)
            {
                Vector<double> currentVector = Vector<double>.Build.DenseOfArray(new double[] { pointsInSphere[i].X, pointsInSphere[i].Y, pointsInSphere[i].Z });
                currentVector -= meanVector;

                a.SetColumn(i, currentVector);
            }

            return a * a.Transpose();
        }

        private static Vector<double> CalculateWeightedMeanVector(List<Point3D> pointsInSphere, List<double> values, double threshold, double max)
        {
            Vector<double> meanVector = Vector<double>.Build.Dense(3);
            double weightSum = 0;

            for (int i = 0; i < pointsInSphere.Count; i++)
            {
                /* Filter insignificant values */
                if (threshold > values[i])
                    continue;

                double weight = (values[i] - threshold) / (max - threshold); // Calculate the weight

                meanVector[0] += pointsInSphere[i].X * weight;
                meanVector[1] += pointsInSphere[i].Y * weight;
                meanVector[2] += pointsInSphere[i].Z * weight;

                weightSum += weight;
            }

            meanVector /= weightSum;
            return meanVector;
        }

        /// <summary>
        /// Gets points uniformly distributed from the center point
        /// </summary>
        /// <param name="p">Center around which the points are generated</param>
        /// <param name="r">Generated point's distance from the center</param>
        /// <param name="spacing">Spacing between the points</param>
        /// <param name="data">Data unsed for checking if the value is within bounds of the object.</param>
        /// <returns>A grid of points uniformly distributed in the sphere radius from a given point.</returns>
        private static List<Point3D> GetSphere(Point3D p, double r, double spacing, AData data)
        {
            List<Point3D> points = new List<Point3D>();

            for(double x = -r; x<=r; x+=spacing)
            {
                for(double y = -r; y<=r; y+=spacing)
                {
                    SphereBounds zBounds;

                    try { zBounds = GetSphereBounds(x, y, r); }
                    catch { continue; } //No point in z is in the bounds

                    for (double z = zBounds.MinCoordinate; z <= zBounds.MaxCoordinate; z += spacing)
                    {
                        Point3D point = new Point3D(x + p.X, y + p.Y, z + p.Z);
                        if (data.PointWithinBounds(point))
                            points.Add(point);
                    }
                }
            }

            return points;
        }


        /// <summary>
        /// Given an x and y coordinates, this method will generate a min and max z coordinate
        /// so that [x, y, z] are inside a sphere specified by given radius
        /// </summary>
        /// <param name="x">Coordinate X</param>
        /// <param name="y">Coordinate Y</param>
        /// <param name="radius">Radius of a sphere</param>
        /// <returns>Returns instance of SphereBounds where are the min and max Z values.</returns>
        /// <exception cref="ArgumentException">Throws an exception if the bounds for Z don't exist.</exception>
        private static SphereBounds GetSphereBounds(double x, double y, double radius)
        {
            double rSquared = Math.Pow(radius, 2);
            double zSquared = rSquared - Math.Pow(x, 2) - Math.Pow(y, 2);

            if (zSquared < 0)
                throw new ArgumentException("No values are within bounds for the given X, Y coordinates and given radius");

            double minZ = -Math.Sqrt(zSquared);
            double maxZ = -minZ;
            return new SphereBounds(minZ, maxZ);
        }

        /// <summary>
        /// Returns random number within the specified bounds
        /// </summary>
        /// <param name="minimum">Minimum number to be generated</param>
        /// <param name="maximum">Maximum number to be generated</param>
        /// <param name="r">Instance of Random class</param>
        /// <returns></returns>
        private static double GetRandomDouble(double minimum, double maximum, Random r)
        {
            return r.NextDouble() * (maximum - minimum) + minimum;
        }
        
    }
}